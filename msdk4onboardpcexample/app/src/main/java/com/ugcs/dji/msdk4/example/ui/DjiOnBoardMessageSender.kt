package com.ugcs.dji.msdk4.example.ui

import dji.common.error.DJICameraError
import dji.common.error.DJIError
import dji.keysdk.FlightControllerKey
import dji.sdk.flightcontroller.FlightController
import dji.sdk.flightcontroller.FlightController.OnboardSDKDeviceDataCallback
import dji.sdk.sdkmanager.DJISDKManager
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.launch
import timber.log.Timber
import java.io.Closeable
import java.nio.charset.StandardCharsets
import java.util.concurrent.TimeoutException
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlin.coroutines.suspendCoroutine

class DjiOnBoardMessageSender(
	fc: FlightController,
	val coroutineScope: CoroutineScope
): Closeable, OnboardSDKDeviceDataCallback {

	val isOnBoardSdkAvailableKey =
		FlightControllerKey.create(FlightControllerKey.IS_ON_BOARD_SDK_AVAILABLE)
	val isOnboardSdkAvailable = MutableStateFlow<Boolean?>(false)
	val receivedData = mutableListOf<String>()
	val receivedDataFlow = MutableSharedFlow<String>()
	var flightController: FlightController? = null
	var listener: (Any?, Any?) -> Unit = { _, newValue ->
		isOnboardSdkAvailable.value = newValue as? Boolean?
	}

	init {
		flightController = fc.also {
			it.setOnboardSDKDeviceDataCallback(this@DjiOnBoardMessageSender)
		}
		val keyManager = DJISDKManager.getInstance().keyManager
		if (keyManager != null) {
			val value = keyManager.getValue(isOnBoardSdkAvailableKey)
			isOnboardSdkAvailable.value = value as? Boolean
			keyManager.addListener(isOnBoardSdkAvailableKey, listener)
		}
	}

	suspend fun sendTestMessage() {
		if (flightController == null)
			throw IllegalStateException("Drone isn't connected.");

		if (isOnboardSdkAvailable.value != true)
			throw IllegalStateException("Onboard SDK isn't initialized yet.");


		return suspendCoroutine { continuation ->
			val message = "Hello MSDK4 onboard"
			val bytes = message.toByteArray()
			Timber.i(
				"Sending message '%s'[%d bytes] to the onboard computer.",
				message,
				bytes.size
			)

			flightController!!.sendDataToOnboardSDKDevice(bytes) { djiError: DJIError? ->
				if (djiError != null) {
					Timber.e("Message '%s' sending failed: %s", message, djiError)
					continuation.resumeWithException(
						djiError.asException()
					)
				} else {
					Timber.d("The message '%s' sent successfully.", message)
					continuation.resume(Unit);
				}
			}
		};
	}

	override fun onReceive(bytes: ByteArray?) {
		Timber.i("%d bytes received from the onboard computer.", bytes?.size)
		val response = bytes?.toString(StandardCharsets.UTF_8)
		Timber.i("Received message: %s", response)
		receivedData.add(response ?: "null")
		coroutineScope.launch {
			receivedDataFlow.emit(response ?: "null")
		}
	}

	override fun close() {
		val keyManager = DJISDKManager.getInstance().keyManager
		if (keyManager != null) {
			keyManager.removeListener(listener)
		} else {
			throw IllegalStateException("Key manager is null. Cannot unsubscribe from key")
		}
	}
}

fun DJIError?.asException(): Throwable {
	fun buildErrorMessage(djiError: DJIError): String {
		return djiError.description
	}

	class DJIErrorException constructor(val djiError: DJIError) :
		Exception(buildErrorMessage(djiError))


	return if (this == null)
		DjiUnknownException()
	else when (this) {
		DJICameraError.NOT_SUPPORT_FEATURE,
		DJIError.COMMON_UNSUPPORTED -> UnsupportedOperationException(description)

		DJIError.COMMON_TIMEOUT -> TimeoutException(description)
		else -> DJIErrorException(this)
	}
}

/**
 * Represents an error generated by DJI MSDK without any details.
 */
class DjiUnknownException : Exception("DJI MSDK operation failed due to an unknown error.") {
}